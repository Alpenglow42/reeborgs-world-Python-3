#incomplete see notes on bottom


w = 0
y = 0
x = 0
z = 1
o = 0
a = 0
b = 0
def turn_right():
    #3 lefts make a right
    turn_left()
    turn_left()
    turn_left()
    
def turn_around():
    turn_left()
    turn_left()

def take_object():
    #o = 1
    global o
    while object_here():
        take()
        o += 1
        #y += 1

def check_pond():
    if not front_is_clear(): #check for pond by seeing if can go around.
            turn_left()
            if front_is_clear(): #if not reset
                move()
                turn_right()
                if front_is_clear(): #first step around
                    move()
                    if front_is_clear(): # will hit wall if not pond here
                        move()
                        turn_right()
                        if front_is_clear():# second step full around
                            move()
                            turn_left()
                    elif not front_is_clear(): # reverse path if not a pond
                        turn_around()
                        move()
                        turn_left()
                        move()
                        turn_around() #facing orginal direction now
                    
def count_width():
    while front_is_clear():
        global a
        move()
        take_object()
        a += 1
        print(f"a = {a}")

def first_left():
    if not front_is_clear():
        global y
        turn_left()
        move()
        take_object()
        turn_left()
        y += 1        
        
def compare_width():
    while front_is_clear():
        global b
        move()
        take_object()
        b += 1
        #if b != a :
            #check_pond()
def trash_bin():
    while front_is_clear():
        take_object()
        move()

def first_right():
    if not front_is_clear():
        global y
        turn_right()
        move()
        take_object()
        turn_right()
        y = 0        
    
# storm     
#think(2)

count_width()
first_left()
trash_bin()
first_right()

while z == 1:
    take_object()
    #while object_here():
        #take()
        #y += 1
        #move()
        #x += 1
    if not object_here():
        if front_is_clear():
            compare_width()
            x += 1
        
        
                    
        elif not front_is_clear(): #and wall_on right():
            if y < 1: #left turn
                turn_left()
                move()
                take_object()
                turn_left()
                y += 1
                w += 1
            elif y >= 1 and w < 3: #right turn
                turn_right()
                move()
                take_object()
                turn_right()
                y = 0 
                 
            elif w >= 3: #last bit to bin toss
                turn_left()
                while front_is_clear():
                    move()
                    take_object()
                    if not front_is_clear(): #and if not wall_on right():
                        #toss()
                        for x in range (o):
                            toss() #need to toss in range of objects found
                         
                        if w == 3:# return to starting point    
                            turn_left()
                            move()
                            turn_right()
                            move()
                            move()
                            turn_right()
                            move()
                            done()

# notes: 1.)need to complete trigger or count to toss leaves and come back home
# notes: 2.) need to differentiate between wall and pond.
# notes: 3.) while bin is take care of by function trash_bin() may only need to use if/elif
# notes cont.: statment to compare between a wall and pond

           
